20130108
    V2.5
        修改托管属性的注册行为，不再在程序启动时加载所有属性，而是在运行时按需注册需要的属性。属性注册的顺序是：
        * 启动时，需要先注册所有的编译期扩展属性。
        * 注册该类型自身定义的所有编译期正常属性。
        * 运行时注册的运行期动态属性。

20121118
    V2.0
        为了提升托管属性的性能，把托管属性对象中存储的字段、属性变更事件参数，都由引用类型改为结构体，并取消相应的接口，防止结构体转换为接口时的隐式装箱操作。
        （
            上一版本使用泛型加接口的结构设计，主要是为了避免在属性调用强类型的 GetProperty、SetProperty 时不会产生装箱拆箱。但是缺点是每一个字段都是一个对象、每一次属性变更都会产生一个属性变更事件参数对象。
            其实，随着一年多的使用，发现装箱、拆箱是无法避免的：不论是从数据库中直接加载数据、还是界面层、传输层框架对属性的使用，都是使用 IManagedProperty 接口面向装箱后的 object 类型的属性值来操作的。如果每个字段存储的是强类型 TPropertyType 时，那么框架的这每一个操作，都会伴随着装箱、拆箱。而目前大部分性能密集型的使用场景其实都是上层框架直接使用这些属性，所以决定把底层存储的字段，改为直接使用装箱后的 object 类型。
            这样的缺点是，应用层在直接使用对象的 CLR 属性调用强类型的 GetProperty、SetProperty 时，会发生装箱拆箱。但是这个缺点暂时无法克服。
        
            其实，DataTable 模式下也有一样的问题，统一存储属性后，必须导致大量的装箱拆箱。
            另外，WPF DependencyObject 虽然也是一样的模式，但是其使用场景完全不一样，它的属性值大多是引用类型，所以不存在性能问题。
        ）

2011-11
    V1.0
        之前一直使用 CSLA 的属性框架。但是为了达到动态添加实体属性的功能，所以重写了最底层的属性框架。为了保证兼容，结构设计上参考了 CSLA 框架。